# Звіт до Лабораторної роботи №4: Аналітичні SQL-запити

## Частина 1: Агрегація та Групування (Aggregation & Grouping)

### Запит 1. Загальний дохід магазину

**Мета:** Отримати фінансовий звіт про загальний обіг коштів у магазині.

```sql
SELECT SUM(amount) AS total_revenue
FROM Payment;
```

- **Як це працює:** Функція `SUM(amount)` підсумовує всі значення у стовпці `amount` таблиці `Payment`.
- **Результат:** Одне число, яке показує сумарний виторг за весь час.

### Запит 2. Статистика цін товарів

**Мета:** Проаналізувати цінову політику (найдешевший, найдорожчий та середній товар).

```sql
SELECT
    MIN(price) AS min_price,
    MAX(price) AS max_price,
    AVG(price) AS average_price
FROM Product;
```

- **Як це працює:** Використовуються агрегатні функції `MIN` (мінімум), `MAX` (максимум) та `AVG` (середнє значення) для стовпця `price`.
- **Результат:** Зведений рядок із ціновими показниками асортименту.

### Запит 3. Кількість товарів у кожній категорії

**Мета:** Аналіз наповненості складу по категоріях.

```sql
SELECT category_id, COUNT(*) AS product_count
FROM Product
GROUP BY category_id
ORDER BY product_count DESC;
```

- **Як це працює:** Оператор `GROUP BY category_id` групує товари за категоріями, а `COUNT(*)` рахує кількість записів у кожній групі. Сортування `DESC` показує найбільші категорії зверху.
- **Результат:** Список категорій із зазначенням кількості товарів у кожній.

### Запит 4. Фільтрація популярних категорій

**Мета:** Визначити основні категорії товарів (де асортимент \> 2 одиниць).

```sql
SELECT category_id, COUNT(*) AS product_count
FROM Product
GROUP BY category_id
HAVING COUNT(*) > 2;
```

- **Як це працює:** Використовується `HAVING` для фільтрації вже згрупованих даних. Групи, де `COUNT` менше або дорівнює 2, відкидаються.
- **Результат:** Скорочений список лише наповнених категорій.

---

## Частина 2: Об'єднання таблиць (JOIN)

### Запит 5. Деталізація замовлень (INNER JOIN)

**Мета:** Отримати зрозумілий список проданих товарів із назвами замість ID.

```sql
SELECT
    oi.order_id,
    p.name AS product_name,
    oi.quantity,
    oi.price AS unit_price
FROM OrderItem oi
INNER JOIN Product p ON oi.product_id = p.product_id;
```

- **Як це працює:** `INNER JOIN` залишає тільки ті рядки, де є відповідність між `OrderItem` та `Product`.
- **Результат:** Таблиця позицій замовлення з розшифровкою назв товарів.

### Запит 6. Клієнти та історія замовлень (LEFT JOIN)

**Мета:** Виявити всіх клієнтів, включаючи тих, хто не робив замовлень (для маркетингу).

```sql
SELECT
    c.name AS customer_name,
    o.order_id,
    o.total_amount
FROM Customer c
LEFT JOIN "Order" o ON c.customer_id = o.customer_id;
```

- **Як це працює:** `LEFT JOIN` повертає всіх клієнтів. Якщо у клієнта немає замовлень, у колонках замовлення буде `NULL`.
- **Результат:** Повний список клієнтів. `NULL` у полі `order_id` вказує на неактивного клієнта.

### Запит 7. Аудит категорій (RIGHT JOIN)

**Мета:** Знайти категорії, які існують у базі, але не мають прив'язаних товарів.

```sql
SELECT
    p.name AS product_name,
    c.name AS category_name
FROM Product p
RIGHT JOIN Category c ON p.category_id = c.category_id;
```

- **Як це працює:** `RIGHT JOIN` гарантує вивід усіх категорій (права таблиця). Товари приєднуються до них.
- **Результат:** Список категорій. Якщо `product_name` = `NULL`, категорія порожня.

---

## Частина 3: Підзапити

### Запит 8. Товари дорожчі за середнє

**Мета:** Виділити преміум-сегмент товарів.

```sql
SELECT name, price
FROM Product
WHERE price > (SELECT AVG(price) FROM Product);
```

- **Як це працює:** Підзапит `(SELECT AVG...)` обчислює середню ціну по всьому магазину. Основний запит фільтрує товари, ціна яких вища за це значення.
- **Результат:** Список товарів з ціною вище середньої.

### Запит 9. Персональний лічильник замовлень

**Мета:** Швидкий перегляд активності клієнтів без групування основної вибірки.

```sql
SELECT
    c.name,
    c.email,
    (SELECT COUNT(*) FROM "Order" o WHERE o.customer_id = c.customer_id) AS total_orders
FROM Customer c;
```

- **Як це працює:** Для кожного рядка клієнта виконується окремий підзапит, що рахує його замовлення.
- **Результат:** Список клієнтів з колонкою `total_orders`.

### Запит 10. Таргетинг за товаром

**Мета:** Знайти клієнтів, які купили певний товар (наприклад, 'Laptop').

```sql
SELECT name
FROM Customer
WHERE customer_id IN (
    SELECT o.customer_id
    FROM "Order" o
    JOIN OrderItem oi ON o.order_id = oi.order_id
    JOIN Product p ON oi.product_id = p.product_id
    WHERE p.name = 'Laptop'
);
```

- **Як це працює:** Внутрішній запит формує список ID покупців ноутбуків. Зовнішній запит обирає імена клієнтів, чиї ID входять у цей список.
- **Результат:** Імена клієнтів цільової групи.

---

## Частина 4: Комплексна аналітика

### Запит 11. Рейтинг клієнтів за витратами

**Мета:** Визначити клієнтів, які мають найбільші витрати.

```sql
SELECT
    c.name AS customer_name,
    COUNT(o.order_id) AS orders_count,
    COALESCE(SUM(o.total_amount), 0) AS total_spent
FROM Customer c
LEFT JOIN "Order" o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name
ORDER BY total_spent DESC;
```

- **Як це працює:** 1. `LEFT JOIN` об'єднує клієнтів із замовленнями.
  2\. `GROUP BY` групує дані по клієнту.
  3\. `SUM` рахує загальну суму витрат, а `COALESCE` замінює `NULL` на `0` для порожніх замовлень.
  4\. `ORDER BY ... DESC` сортує клієнтів від найприбутковіших до найменш активних.
- **Результат:** Рейтингова таблиця витрат клієнтів.

```

```
